# -*- coding: utf-8 -*-
"""multidcp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1odxHtdEU-4-yBEwdyRfVQtJM6Yir03Eb
"""

import cv2
import numpy as np
import os
from glob import glob
import matplotlib.pyplot as plt

def get_dark_channel(image, size=15):
    b, g, r = cv2.split(image)
    min_img = cv2.min(cv2.min(r, g), b)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (size, size))
    dark_channel = cv2.erode(min_img, kernel)
    return dark_channel

def get_atmospheric_light(image, dark_channel):
    h, w = image.shape[:2]
    num_pixels = h * w
    num_brightest_pixels = int(max(num_pixels * 0.001, 1))

    dark_vec = dark_channel.reshape(num_pixels)
    image_vec = image.reshape(num_pixels, 3)

    indices = np.argsort(dark_vec)[-num_brightest_pixels:]
    atmospheric_light = np.mean(image_vec[indices], axis=0)

    return atmospheric_light

def get_transmission_estimate(image, atmospheric_light, size=15, omega=0.95):
    normalized_image = image / atmospheric_light
    transmission_estimate = 1 - omega * get_dark_channel(normalized_image, size)
    return transmission_estimate

def guided_filter(I, p, r, eps):
    mean_I = cv2.boxFilter(I, cv2.CV_64F, (r, r))
    mean_p = cv2.boxFilter(p, cv2.CV_64F, (r, r))
    mean_Ip = cv2.boxFilter(I * p, cv2.CV_64F, (r, r))
    cov_Ip = mean_Ip - mean_I * mean_p

    mean_II = cv2.boxFilter(I * I, cv2.CV_64F, (r, r))
    var_I = mean_II - mean_I * mean_I

    a = cov_Ip / (var_I + eps)
    b = mean_p - a * mean_I

    mean_a = cv2.boxFilter(a, cv2.CV_64F, (r, r))
    mean_b = cv2.boxFilter(b, cv2.CV_64F, (r, r))

    q = mean_a * I + mean_b
    return q

def get_refined_transmission(image, estimated_transmission):
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) / 255.0
    refined_transmission = guided_filter(gray_image, estimated_transmission, 60, 1e-4)
    return refined_transmission

def recover_image(image, transmission, atmospheric_light, t0=0.1):
    transmission = np.maximum(transmission, t0)
    transmission = cv2.merge([transmission, transmission, transmission])
    recovered_image = (image - atmospheric_light) / transmission + atmospheric_light
    recovered_image = np.clip(recovered_image, 0, 255).astype(np.uint8)
    return recovered_image

def dehaze_image(image_path):
    image = cv2.imread(image_path)
    dark_channel = get_dark_channel(image)
    atmospheric_light = get_atmospheric_light(image, dark_channel)
    transmission_estimate = get_transmission_estimate(image, atmospheric_light)
    refined_transmission = get_refined_transmission(image, transmission_estimate)
    recovered_image = recover_image(image, refined_transmission, atmospheric_light)
    return recovered_image

def dehaze_images_in_folder(folder_path, output_folder):
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    for filename in os.listdir(folder_path):
        if filename.endswith(('.png', '.jpg', '.jpeg', '.bmp')):
            image_path = os.path.join(folder_path, filename)
            output_path = os.path.join(output_folder, filename)
            dehazed_image = dehaze_image(image_path)
            cv2.imwrite(output_path, dehazed_image)
            print(f'Dehazed image saved at: {output_path}')

# Paths to the dataset on Google Drive
input_folder = '/content/drive/MyDrive/RESIDE_2/train/hazy'
output_folder = '/content/output'

dehaze_images_in_folder(input_folder, output_folder)